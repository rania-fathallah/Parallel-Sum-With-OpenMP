# Parallel Sum With OpenMP

 The task at hand involves efficiently computing the sum of two long integers
using the Carry Look Ahead (CLA) approach, leveraging the parallel processing
capabilities offered by OpenMP in C. This optimization aims to reduce
computation time significantly, catering to scenarios where rapid addition of
large numbers is required, such as in scientific computing, cryptography, and
data processing.

## How to compile and run

   1-Compilation : 
   ```bash
   gcc sumPar -o sum
   ```
                                                                     
   3-Ex√©cution : 
   ```bash
   ./sum <input.txt
   ```

Input File Example:
   ```bash
 cat input.txt
   455 544
   ```

## Algorithm

   To optimize the addition process using the Carry Look Ahead (CLA) approach and
parallel programming with OpenMP, we follow a systematic approach:
      1. Identifying Generative and Propagative Integers: Initially, we determine
whether each individual integer in the sum is generative or propagative. This
step is parallelizable since there are no dependencies between the variables. We
can distribute the computation of each integer's generativity or propagativity
across multiple threads, maximizing parallel efficiency.(we used parallel for in
this part)
      2. Determining Carry Presence: Subsequently, we ascertain whether there is a
carry for each integer based on the generativity/propagativity of the integer
and the carry status from the preceding integer. This step cannot be
parallelized as it involves dependencies between successive integers.
      3. Summation with Carry: In this phase, we perform the summation operation
for each integer while incorporating any carry generated from the preceding
integer. Although each summation operation depends on the result of the previous
one, the determination of carry presence for all sums before the summation
renders this phase parallelizable. Leveraging parallel for directives, we
distribute the computation of summation across multiple threads, enhancing
parallel efficiency and accelerating the addition process. This optimized
approach ensures that each integer's addition is seamlessly integrated with
carry propagation, leading to efficient and rapid computation of the sum of long
integers.

   By strategically partitioning the addition process into parallelizable and
sequential segments, we exploit the benefits of parallel processing while
addressing the inherent dependencies within the algorithm. This optimized
approach ensures efficient computation of long integer sums, catering to
scenarios where rapid addition is paramount.

##  Performance

   While assessing the performance of both parallel and sequential algorithms for
summing long integers, it became apparent that the parallel implementation
exhibited inferior efficiency compared to its sequential counterpart. This
disparity may stem from the substantial overhead incurred by the parallel
algorithm in managing a large number of tasks. On a computer with a limited
number of cores, such as eight, the overhead of creating and managing additional
tasks outweighs the potential performance benefits, as the number of parallel
tasks exceeds the available cores. This process of forking and joining tasks
consumes significant time, detracting from overall efficiency. However, on a
system with a larger number of cores or even infinite cores, the parallel
algorithm would likely demonstrate improved performance, as the overhead of task
management becomes negligible relative to the increased parallel processing
capacity. Thus, it is essential to optimize task creation to match the available
parallel resources for optimal performance.


   The computation time does not follow a linear trend, likely due to its
dependency on the state of the computer.

## Implementation

### The functions

   char* carryLookaheadAddition(char* num1, char* num2) :

-> This function implements the addition operation using the Carry Look
Ahead Addition algorithm.


   bool isPropagate(int input1, int input2):

-> This function determines whether the two inputs propagate or not. They
propagate if their sum is 9.


   bool isGenerate(int input1, int input2):

-> This function determines whether the two inputs generate or not. They
generate if their sum is greater than 9.


   bool hasCout(bool g, bool p, bool cin):

This function takes three boolean inputs:
   - p: Indicates whether it propagates or not.
   - g: Indicates whether it generates or not.
   - cin: Indicates whether there is a carry from the previous sum (carry-
in).
-> Then, it determines the carry-out (cout).

## Testing:
   A variety of inputs were manually entered to evaluate the code, and the
resulting outputs were compared against those generated by the sequential
algorithm.
